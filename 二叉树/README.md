#二叉树

> 二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

## 两种解题思路

二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 **回溯算法核心框架** 和 **动态规划核心框架**。

### 综上，遇到一道二叉树的题目时的通用思考过程是：

1. **是否可以通过遍历一遍二叉树得到答案**? 如果可以，用一个 traverse 函数配合外部变量来实现。
2. **是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。
3. **无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做**。

## 后序位置的特殊之处
[二叉树前中后序](../images/二叉树前中后序.jpeg)

- 二叉树的前序遍历只能从函数参数中获取父节点的数据
- 而后序遍历不仅可以获取到参数数据，还可以获取到子树的信息

举具体的例子，现在给你一棵二叉树，我问你两个简单的问题：

1. 如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

2. 如何打印出每个节点的左右子树各有多少节点？

第一个问题
```javascript
// 二叉树遍历函数
function traverse(root, level) {
    if (!root) {
        return;
    }
    // 前序位置
    console.log(`节点${root}在第${level}层`);
    traverse(root.left, level + 1);
    traverse(root.right, level + 1);
}

// 这样调用
traverse(root, 1);
```
第二个问题
```javascript
function countBfs(root) {
  if(!root) {
    return 0
  }
  const leftCount = countBfs(root.left);
  const rightCount = countBfs(root.right);
  console.log(`节点${root}左子树节点个数${leftCount}，右子树节点个数${rightCount}`);
  return leftCount + rightCount + 1;
}
```

> **那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**
